import numpy as np
from numpy.polynomial.polynomial import polyfit, polyvander, polyval

def basecorr1D(x=None, y=None, polyorder=0, window=20, *args,**kwargs):
    '''
    Function that achieve a baseline correction by fitting a function a the 
    edge of the data via a window parameter.
    The baseline correction is carried out via the polyfit function:
        (https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polyfit.html)
    that Compute least-squares solution to equation V(x) * c = w * y, with V the
    Vandermonde matrix, c the polynomial coefficient, w some weights parameters
    and y the data column vector.
    
    p(x) = c_0 + c_1 * x + ... + c_n * x^n,
    
    Parameters
    ----------
    x : numpy array, column vector
        DESCRIPTION. The default is None.
    y : numpy array, column vector
        It has to have the same size than x
        DESCRIPTION. The default is None.
    polyorder : TYPE, optional
        DESCRIPTION. The default is 0.
    window : TYPE, optional
        DESCRIPTION. The default is 20.
    *args : TYPE
        DESCRIPTION.
    **kwargs : TYPE
        DESCRIPTION.

    Raises
    ------
    ValueError
        DESCRIPTION.

    Returns
    -------
    ynew : TYPE
        DESCRIPTION.
    c : TYPE
        DESCRIPTION.
    error_parameters : TYPE
        DESCRIPTION.
    cov : TYPE
        DESCRIPTION.

    '''
    if x.shape[0] != np.ravel(x).shape[0]:
        raise ValueError('y must be a column vector. basecorr1D function does not work on 2D arrays.')
    else:
        x = np.ravel(x)

    if y.shape[0] != np.ravel(y).shape[0]:
        raise ValueError('y must be a column vector. basecorr1D function does not work on 2D arrays.')
    else:
        y = np.ravel(y)
        
    if y.shape[0] != x.shape[0]:
        raise ValueError('x and y must be column vector of the same size.')

    ynew = np.full(y.shape,np.nan)
    xfit = np.array([x[:window],x[-window:]]).ravel()
    yfit = np.array([y[:window],y[-window:]]).ravel()
    c, stats = polyfit(xfit,yfit,polyorder,full=True) 
    ynew = y-polyval(x,c)
    error_parameters,cov = error_vandermonde(x,residuals=stats[0],rank=polyorder)
    return ynew,c,error_parameters,cov

def error_vandermonde(x,residuals=None,rank=None,*args,**kwargs):
    '''
    Function to generate 1) error estimation on parameters determined by the function
    coef, [residuals, rank, singular_values, rcond] = numpy.polynomial.polynomial.polyfit()
    2) covariance matrix associated.
    
    The Vandermonde matrix generated by vand = polyvander(x,rank)
    The Covariance matrix cov is obtained via the vandermonde matrix V 
    via this numerical steps:
        1) compute np.dot(V.T,V).inv 
        2) and multiply it by the residual/(nb of data points - nb of coefficients)
    The error parameters are then computed via : error_parameters = np.sqrt(np.diag(cov))
    
    Parameters
    ----------
    residuals : first value generated by polyfit in the list of the second output
        DESCRIPTION. float number. The default is None.
    vandermonde : Vandermonde matrix generated by vand = polyvander(x,rank)
        DESCRIPTION. The default is None.
    ???
    ydim : necessary for multidimensional array
        DESCRIPTION. The default is None.
    ???
    
    Raises
    ------
    ValueError if rank is higher than the number of points
        "the number of data points must exceed order "
                                 "to scale the covariance matrix".

    Returns
    -------
    error_parameters : error uncertainties estimated on the parameters ordered 
    from low to high polynomial order.
    By example for a linear model f(x)=a0+a1*x : 
        error_parameters[0] = constant parameters a0, 
        error_parameters[1] = slope a1.
        
    covariance : covariance estimated for the Least-squares fit of a polynomial to data
        return a Matrix(Rank by rank)
    '''
    if len(x) <= rank:
        raise ValueError("the number of data points must exceed order "
                                 "to scale the covariance matrix")
    else:
        v = polyvander(x,rank) # generate the vandermonde matrix
        cov = residuals/(len(x) - rank)*np.linalg.inv(np.dot(v.T, v))
        error_parameters=np.sqrt(np.diag(cov))
    
    return error_parameters,cov
